// Auto-generated from components.html.
// DO NOT EDIT.

library components_html;

import 'dart:html' as autogenerated;
import 'dart:svg' as autogenerated_svg;
import 'package:web_ui/web_ui.dart' as autogenerated;

import 'dart:html';

import 'dart:async';

import 'package:web_ui/web_ui.dart';

import 'model_viewer.dart';


// Original code
ModelViewerComponent _modelViewerComponent;
/// URL to the conversion API.
const String _convertUrl = 'http://127.0.0.1:3000/api/convert';
/// The [FileSystem] to write to.
FileSystem _fileSystem;
/// The largest model size to expect.
///
/// Using a temporary filesystem so the user doesn't have to be
/// prompted.
const int _maxModelSize = 2 * 1024 * 1024;

/// Convert the models.
void _convertModel(_) {
  FormElement form = query('form');
  FormData formData = new FormData(form);

  HttpRequest request = new HttpRequest();
  request.open('POST', _convertUrl);
  request.onLoadEnd.listen((_) {
    if (_fileSystem != null) {
      // Show the file contents
      TextAreaElement textArea = query('#modelFile');
      textArea.value = request.responseText;

      // Write out the file
      _writeText('model.mesh', request.responseText).then((modelUrl) {
        _modelViewerComponent.loadModelFromUrl(modelUrl);
      });
    }
  });

  request.send(formData);
}

/// Application loop.
void _onUpdate(double time) {
  // Update the animation
  _modelViewerComponent.update(time);

  // Draw the scene
  _modelViewerComponent.draw();

  // For the animation to continue the function
  // needs to set itself again
  window.requestAnimationFrame(_onUpdate);
}

/// Starts up the application.
///
/// There's a delay between when [main] is called and when the web
/// components are actually ready to be used. Because of this the
/// initialization can't actually happen in main.
void _startup() {
  // Load the model viewer
  _modelViewerComponent = query('#model_viewer').xtag;
  _modelViewerComponent.loadModelFromUrl('../meshes/cube.mesh');

  // Hook into the submit button
  InputElement submitButton = query('#convertModel');
  submitButton.onClick.listen(_convertModel);

  // Request storage
  window.webkitStorageInfo.requestQuota(StorageInfo.TEMPORARY, _maxModelSize,
    (grantedBytes) {
      // Request the file system
      window.requestFileSystem(StorageInfo.TEMPORARY, grantedBytes, _onFileSystemCreated, _onFileSystemError);
    },
    (error) {
      print(error);
    }
  );

  // Start up the animation loop
  window.requestAnimationFrame(_onUpdate);
}

/// Callback for when the [FileSystem] is created.
void _onFileSystemCreated(FileSystem fileSystem) {
  _fileSystem = fileSystem;
}

/// Callback for when an error occurs when using the [FileSystem].
void _onFileSystemError(FileError error) {
  String messageCode = '';

  switch (error.code) {
    case FileError.QUOTA_EXCEEDED_ERR: messageCode = 'Quota Exceeded'; break;
    case FileError.NOT_FOUND_ERR: messageCode = 'Not found '; break;
    case FileError.SECURITY_ERR: messageCode = 'Security Error'; break;
    case FileError.INVALID_MODIFICATION_ERR: messageCode = 'Invalid Modificaiton'; break;
    case FileError.INVALID_STATE_ERR: messageCode = 'Invalid State'; break;
    default: messageCode = 'Unknown error'; break;
  }

  print('Filesystem error: $messageCode');
}

/// Writes a text file to disk.
Future<String> _writeText(String fileName, String text)
{
  Blob data = new Blob([text], 'text/plain');
  Completer completer = new Completer();

  Map options = { 'create': true };

  _fileSystem.root.getFile(fileName, options: { 'create': true }, successCallback: (fileEntry) {
    fileEntry.createWriter((fileWriter) {
      bool truncated = false;

      fileWriter.on.writeEnd.add((_) {
        if (truncated)
        {
          completer.complete(fileEntry.toUrl());
        }
        else
        {
          fileWriter.write(data);
          truncated = true;
        }
      });

      // Clear the current file
      // The file is not overwritten completely unless
      // a truncate is performed.
      fileWriter.truncate(0);
    });
  }, errorCallback: _onFileSystemError);

  return completer.future;
}

/// Entry-point to the application.
void main() {
  //useShadowDom = true; // to enable use of experimental Shadow DOM in the browser

  // Start up the application
  // Add a delay so the Web Components are initialized
  window.setTimeout(_startup, 0);
}


// Additional generated code
void init_autogenerated() {
  var _root = autogenerated.document.body;
  var __convertModel, __modelFile, __model_viewer;

  var __t = new autogenerated.Template(_root);
  __model_viewer = _root.query('#model_viewer');
  __t.oneWayBind(() => (480), (e) { __model_viewer.xtag.height = e; }, false);
  __t.oneWayBind(() => (640), (e) { __model_viewer.xtag.width = e; }, false);
  new ModelViewerComponent.forElement(__model_viewer);
  __t.component(__model_viewer);
  __convertModel = _root.query('#convertModel');
  __modelFile = _root.query('#modelFile');
  

  __t.create();
  __t.insert();
}
